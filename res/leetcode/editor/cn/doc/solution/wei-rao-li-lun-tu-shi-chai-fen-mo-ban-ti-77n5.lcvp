### 解题思路

看到示例，我直接好家伙！这不就是传说中的**差分题**嘛～ 当然当然，区间问题，熟悉**线段树**或者**树状体数组**的小伙伴应该也会有其他的想法，迫于马上就要开始辛劳的搬砖活动，晚点有时间再更新这两种解法吧。
![image.png](https://pic.leetcode-cn.com/1630376673-LJCVsL-image.png)

我们为示例作图讲解，为了方便手残的我在excel上画图，我们将数据内涵稍微做一些变化。
![image.png](https://pic.leetcode-cn.com/1630377706-vmXUNp-image.png)

图中进行了三次预定，分别用绿色 蓝色 黄色表示。
绿色的预定航班为 [1,3] 预订了3个位置
蓝色的预定航班为 [2,4] 预订了2个位置
黄色的预定航班为 [3,5] 预订了4个位置

我们先用比较暴力的方式对问题进行求解，其实就是逐个统计每个航班被三次预定分别预订了几个位置，然后累计求和即可。在表格中就是橙色区域的求法，我们把每个位置都分别染上不同的颜色，然后加起来。 这样大致是O(n*n)的复杂度。

但我们在作图的时候其实很容易发现，每次预定的时候只有**两个地方会导致预定位置数发生变化。即预定开始的航班，和预定结束的航班号+1的航班**。 开始的地方会导致这个地方增加m个航班，结束的地方不再需要这些位置，所以会减去m个航班。这其实就是差分的全部内涵，实际上也是一种数据压缩的方式。我们并不需要真的记录每个位置的状态，只需要记录有变化的位置即可，他们所持有的信息其实是一样的。具体可以查阅 [差分编码](https://baike.baidu.com/item/%E5%B7%AE%E5%88%86%E7%BC%96%E7%A0%81/7491938)。**而图中给的原始数据其实也可以认为是差分编码后的数据，我们现在要做的事情本质上就是解码。**

具体做法如下，我们用一个数组记录每次预定发生变化的地方。在途中就是绿色区域差分的数据。这样只需要遍历一次booking列表即可得到。**差分的数据如果有重叠，需要叠加**。如某两次预定在同一天开始，或者同一天结束。
最后我们**对差分的数据进行一次积分，即可得到原始数据**。**积分在离散的序列里的表现就是前缀和**啦，即用一个状态逐次累加序列每个位置的值并记录下来。相信大家都已经掌握了吧～

翻译成代码如下。

### 代码

* cpp

```cpp
class Solution {
public:
    vector<int> corpFlightBookings(vector<vector<int>>& bookings, int n) {
        vector<int> diff(n+2, 0);
        vector<int> ans;

        for (auto b: bookings) {
            diff[b[0]] += b[2];
            diff[b[1]+1] -= b[2];
        }

        int seats = 0;
        for (int i = 1; i <= n; i++) {
            seats += diff[i];
            ans.push_back(seats);
        }

        return ans;
    }
};
```

### 关于我

18年毕业于上海交通大学，一个在阿里、字节、腾讯都工作过的工程师，有丰富的面试经验。实在卷不动了，目前(2021.8)在一家开源软件公司从事存储研发，希望在今年多多输出。
欢迎关注我的github github.com/wfnuser 关注存储方向的开源项目
最近建立了一个刷题群 也可以+V：wfnusee 找我闲聊哦 麻烦备注来意和leetcode即可～

同名公众号已出，微信搜索 **微扰理论** 即可关注哦。

最后，如果对你有帮助，**请点个赞哦**！
